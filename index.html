<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reddit Moderation Evaluation</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; line-height: 1.6; padding: 20px; max-width: 800px; margin: 0 auto; }
        textarea, input[type="number"] { width: 100%; margin-bottom: 10px; }
        button { padding: 10px; background-color: #4CAF50; color: white; border: none; cursor: pointer; margin-bottom: 10px; }
        button:hover { background-color: #45a049; }
        #results, #dataPreview, #debug { margin-top: 20px; }
        .progress { width: 100%; background-color: #ddd; margin-bottom: 10px; }
        .progress-bar { width: 0; height: 30px; background-color: #4CAF50; text-align: center; line-height: 30px; color: white; }
    </style>
</head>
<body>
    <h1>Reddit Moderation Evaluation</h1>
    <input type="file" id="csvFile" accept=".csv">
    <input type="number" id="sampleSize" placeholder="Number of samples (default: 800)" value="800">
    <textarea id="prompt" rows="10" placeholder="Enter your main prompt here..."></textarea>
    <button onclick="processFile()">Process File</button>
    <div id="progress" class="progress" style="display:none;">
        <div id="progress-bar" class="progress-bar"></div>
    </div>
    <div id="dataPreview"></div>
    <div id="results"></div>
    <div id="debug"></div>

    <script>
        let df = [];
        let rulesDB = {};
        const API_KEY = 'AIzaSyCQiC59AVdfBfJpGqyatWvlzMq45Is6T6Q';
        const API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro-latest:generateContent';

        async function callGeminiAPI(prompt) {
            const response = await fetch(`${API_URL}?key=${API_KEY}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: {
                        temperature: 0.0,
                        maxOutputTokens: 1024,
                    },
                })
            });

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data = await response.json();
            return data.candidates[0].content.parts[0].text;
        }

        function processFile() {
            const file = document.getElementById('csvFile').files[0];
            const sampleSize = parseInt(document.getElementById('sampleSize').value) || 800;
            const prompt = document.getElementById('prompt').value;
            if (!file) {
                alert('Please select a CSV file');
                return;
            }
            if (!prompt) {
                alert('Please enter a main prompt');
                return;
            }

            Papa.parse(file, {
                complete: function(results) {
                    df = results.data;
                    const header = df[0];
                    df = df.slice(1);  // Remove header
                    df = _.sampleSize(df, sampleSize);  // Random sampling
                    displayDataPreview(header, df);
                    processData(prompt);
                }
            });
        }

        function displayDataPreview(header, data) {
            const previewDiv = document.getElementById('dataPreview');
            previewDiv.innerHTML = '<h2>Data Preview</h2>';
            const table = document.createElement('table');
            table.style.borderCollapse = 'collapse';
            table.style.width = '100%';

            // Add header
            const headerRow = table.insertRow();
            header.forEach(col => {
                const th = document.createElement('th');
                th.textContent = col;
                th.style.border = '1px solid black';
                th.style.padding = '5px';
                headerRow.appendChild(th);
            });

            // Add first 5 rows of data
            data.slice(0, 5).forEach(row => {
                const dataRow = table.insertRow();
                row.forEach(cell => {
                    const td = dataRow.insertCell();
                    td.textContent = cell;
                    td.style.border = '1px solid black';
                    td.style.padding = '5px';
                });
            });

            previewDiv.appendChild(table);
        }

        async function processData(prompt) {
            const progressBar = document.getElementById('progress-bar');
            const progressContainer = document.getElementById('progress');
            progressContainer.style.display = 'block';
            let processedRows = 0;

            for (let index = 0; index < df.length; index++) {
                const row = df[index];
                const subreddit = row[9]; // Assuming subreddit is in the 10th column
                const postTitle = row[3]; // Assuming post_title is in the 4th column
                const postBody = row[4] || "(empty)"; // Assuming post_body is in the 5th column
                const postFlair = row[5] || "(empty)"; // Assuming post_flair is in the 6th column
                const labels = row[8].replace("RULE_", "").replace("|", ","); // Assuming label is in the 9th column

                const policyRules = `
                    - Remember the human. Reddit is a place for creating community and belonging, not for attacking marginalized or vulnerable groups of people.
                    - Abide by community rules. Post authentic content into communities where you have a personal interest.
                    - Respect the privacy of others. Instigating harassment is not allowed.
                    - Do not share or encourage the sharing of sexual content involving minors.
                    - Don't impersonate an individual or entity in a misleading or deceptive manner.
                    - Properly label content that is graphic, sexually-explicit, or offensive.
                    - Keep it legal, and avoid posting illegal content or facilitating illegal transactions.
                    - Don't break the site or interfere with normal use of Reddit.
                `.trim();

                const subredditRules = getRules(subreddit);

                const formattedPrompt = prompt.replace('{subreddit}', subreddit)
                    .replace('{post_title}', postTitle)
                    .replace('{post_body}', postBody)
                    .replace('{post_flair}', postFlair)
                    .replace('{policy_rules}', policyRules)
                    .replace('{subreddit_rules}', subredditRules);

                try {
                    const apiResponse = await callGeminiAPI(formattedPrompt);
                    const extractedResponse = extractJSONFromResponse(apiResponse);
                    df[index].push(extractedResponse.result);
                    df[index].push(extractedResponse.explanation);
                    df[index].push(extractedResponse.confidence);

                    processedRows++;
                    const progress = (processedRows / df.length) * 100;
                    progressBar.style.width = progress + '%';
                    progressBar.textContent = Math.round(progress) + '%';
                } catch (error) {
                    console.error('Error processing row:', error);
                    df[index].push('ERROR');
                    df[index].push('Failed to process');
                    df[index].push(0);
                }
            }

            evaluateResults();
        }

        function extractJSONFromResponse(response) {
            try {
                const jsonStart = response.indexOf('{');
                const jsonEnd = response.lastIndexOf('}') + 1;
                const jsonString = response.slice(jsonStart, jsonEnd);
                return JSON.parse(jsonString);
            } catch (error) {
                console.error('Error parsing JSON from response:', error);
                return { result: 'ERROR', explanation: 'Failed to parse response', confidence: 0 };
            }
        }

        function getRules(subreddit) {
            if (!rulesDB[subreddit]) return "No rules found for this subreddit.";
            let rules = [];
            rulesDB[subreddit].rules.forEach((rule, index) => {
                const name = rule.name.replace(/^rule [# ]*[0-9]+[ .:-]*/i, "");
                const text = `${name}\n${rule.description}`.trim();
                rules.push(`# Rule ${index + 1}: ${text}`);
            });
            return rules.join("\n\n");
        }

        function evaluateResults() {
            const results = document.getElementById('results');
            const debug = document.getElementById('debug');
            const trueLabels = df.map(row => normalizeLabel(row[8])); // Assuming label is in the 9th column
            const predLabels = df.map(row => normalizeLabel(row[10])); // Assuming predicted label is in the 11th column

            const exactMatches = trueLabels.filter((label, i) => _.isEqual(label, predLabels[i])).length;
            const partialMatches = trueLabels.filter((label, i) => 
                (label.size === 0 && predLabels[i].size === 0) || 
                (label.size > 0 && predLabels[i].size > 0 && _.intersection([...label], [...predLabels[i]]).length > 0)
            ).length;

            const exactAccuracy = exactMatches / df.length;
            const partialAccuracy = partialMatches / df.length;

            // Corrected precision calculation
            const count_true_ok_pred_ok = trueLabels.filter((label, i) => label.has("OK") && predLabels[i].has("OK")).length;
            const count_true_not_ok_pred_not_ok = trueLabels.filter((label, i) => !label.has("OK") && !predLabels[i].has("OK")).length;
            const precision = (count_true_ok_pred_ok + count_true_not_ok_pred_not_ok) / df.length;

            results.innerHTML = `
                <h2>Evaluation Results</h2>
                <p>Exact Match Accuracy: ${(exactAccuracy * 100).toFixed(2)}%</p>
                <p>Partial Match Accuracy: ${(partialAccuracy * 100).toFixed(2)}%</p>
                <p>Precision: ${(precision * 100).toFixed(2)}%</p>
            `;

            // Debug output
            debug.innerHTML = '<h2>Debug Information</h2>';
            debug.innerHTML += `<p>Total samples: ${df.length}</p>`;
            debug.innerHTML += `<p>True OK count: ${trueLabels.filter(label => label.has("OK")).length}</p>`;
            debug.innerHTML += `<p>Pred OK count: ${predLabels.filter(label => label.has("OK")).length}</p>`;
            debug.innerHTML += `<p>True not OK count: ${trueLabels.filter(label => !label.has("OK")).length}</p>`;
            debug.innerHTML += `<p>Pred not OK count: ${predLabels.filter(label => !label.has("OK")).length}</p>`;
            debug.innerHTML += `<p>Count (true=OK and pred=OK): ${count_true_ok_pred_ok}</p>`;
            debug.innerHTML += `<p>Count (true!=OK and pred!=OK): ${count_true_not_ok_pred_not_ok}</p>`;

            // Display sample of results
            debug.innerHTML += '<h3>Sample of Results:</h3>';
            df.slice(0, 5).forEach((row, index) => {
                debug.innerHTML += `
                    <p>True Label: ${row[8]}</p>
                    <p>Predicted Label: ${row[10]}</p>
                    <p>Explanation: ${row[11]}</p>
                    <p>Confidence: ${row[12]}</p>
                    <hr>
                `;
            });
        }

        function normalizeLabel(label) {
            if (!label) return new Set(["OK"]);
            const normalized = label.toUpperCase().replace("RULE_", "").replace("POLICY", "P");
            return new Set(normalized.split(/[|,]/));
        }
    </script>
</body>
</html>
